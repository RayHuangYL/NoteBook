[toc]

---

# 1.构造方法

​	构造方法是没有返回值的

```java
class Person{
    private String name;
    private int age;
    public  Person(String n, int a){
        name = n;
        age = a;
    }
    public void tell(){
        System.out.println("姓名：" + name + "年龄：" + age);
    }
}
```

​	疑问：既然构造方法是一个方法，那么为什么不让它定义返回值类型呢？既然构造方法不会返回数据，为什么不用void定义呢？

​	答：如果在构造方法上使用了void，那么此结构就与普通方法的结构完全相同了，这样<u>编译器会认为此方法是一个普通方法</u>，普通方法与构造方法最大的区别：构造方法是在类对象实例化的时候调用的，而普通方法是在类对象实例化产生之后调用的。

# 2.匿名对象

```java
new Person("张三", 10).tell();
```

​	此时依然通过了对象进行了类中tell()方法的调用，但是由于此对象没有任何的引用名称，所以该对象使用一次之后就将成为垃圾，而所有的垃圾将被GC进行回收与释放。

# 3.this关键字

- **this的三个使用场景**：

​		（1）当前类的属性：`this.属性`

​		（2）当前类中的方法（普通方法、构造方法）：`this()`、`this.方法名称（）`

​		（3）描述当前对象

- **不使用this的一个问题**：

```java
class Person{
    private String name;
    private int age;
    public Person(String name, int age){
        name = name;		// 在Java中“{}”是作为一个结构体的边界符，那么在程序里面进行变量（参数和属性都称为变量）使用的时候都会以“{}”作为查找边界	因此该赋值语句，没有访问到类的属性 name
        age = age;
    }
    public void tell(){
        System.out.println("姓名：" + name + "、年龄：" + age);
    }
}
public class JavaDemo {
    public static void main(String[] args) {
        Person per1 = new Person("张三", 18);
        per1.tell();			// 输出为 	姓名：null、年龄：0
    }
}

```

- **注意**：在自己所编写的程序代码中，只要是访问本类中属性的时候，一定要加上"this"实现访问

- **对于本类构造方法的互相调用需要注意以下三点重要问题：**

  构造方法必须在实例化新对象的时候调用，所以`this()`的语句只允许放在==构造方法==的==首行==

  类的构造方法中可以调用类的普通方法，但是类的普通方法不能调用类的构造方法

  构造方法互相调用时，请保留有程序的出口（避免递归构造器调用错误）

```java
class Person{
    private String name;
    private int age;
    public Person(){
        //this("调用下面的双参构造", 18);	     // 报错，和下面的双参构造形成递归调用
        System.out.println("类的一个对象实例化了");
    };
    public Person(String name){
        this();
        this.name = name;
        //this();					// 报错，this()必须放在构造方法的首行
    }
    public Person(String name, int age){
        this(name);
        this.age = age;
    }
    public void tell(){
        // this();				// 报错，普通方法不能调用类的构造函数，因为类的构造函数都是在类的实例化时调用的，类的普通方法则是在类的实例化完成之后调用的
        System.out.println("姓名：" + this.name + "、年龄：" + this.age);
    }
}
```

# 4.写一个简单类

​	对于简单Java类而言，其核心的开发结构如下：

> （1）类名称一定要有意义，可以明确的描述某一类事物
>
> （2）类之中的所有属性都必须使用private进行封装，同时封装后的属性必须要提供有setter、getter方法
>
> （3）类之中可以提供无数多个构造方法，但是必须要保留有无参构造方法
>
> （4）类之中不允许出现有任何的输出语句，所有内容的获取必须返回

```java
class Dept{
    private long deptNo;
    private String dname;
    private String loc;
    public Dept(){}				// 保留无参构造
    public Dept(long deptNo, String dname, String loc){
        this.deptNo = deptNo;
        this.dname = dname;
        this.loc = loc;
    }
    public String getInfo(){
        return "【部门信息】 部门编号：" + this.deptNo + "、部门名称：" + this.dname + "、部门位置：" + this.loc;
    }

    public void setDeptNo(long deptNo){
        this.deptNo = deptNo;
    }
    public void setDname(String dname){
        this.dname = dname;
    }
    public void setLoc(String loc){
        this.loc = loc;
    }
    public long getDeptNo(){
        return this.deptNo;
    }
    public String getDname(){
        return this.dname;
    }
    public String getLoc(){
        return this.loc;
    }
}

public class JavaDemo {
    public static void main(String[] args) {
        Dept dept = new Dept(001, "清华大学", "北京");
        System.out.println(dept.getInfo());
    }
}
```

# 5.Static

- **属性**

<img src="../../images/面向对象编程/image-20200914103926295.png" alt="image-20200914103926295" style="zoom:60%;" />

​		由于`static`修饰的是一个==公共==属性，虽然可以通过类的某个实例化对象来访问，但是最好是通过所有对象的最高代表（类）来进行访问，<u>static属性可以由类名称直接调用</u>

​		static 属性虽然定义在类之中，但是其并不受到类实例化对象的控制。==static属性可以在没有实例化对象的时候使用==。

- **方法**

  （1）static方法只允许调用static属性或static方法

  （2）非static方法允许调用static属性或static方法

# 6.代码块

​	在程序中使用“{}”定义的结构就称为代码块，而后根据代码块出现的位置以及 定义的关键字的不同，代码块可以分为：

普通代码块、构造代码块、静态代码块、同步代码块。

（1）普通代码块

​		普通代码块的主要特点是定义在一个方法之中的代码块

```java
public class JavaDemo {
    public static void main(String[] args) {
        {//代码块
            int x = 10;
            System.out.println("x:" + x);   // 10
        }
        int x = 100;
        System.out.println("x:" + x);      // 100
    }
}
```

​		普通代码块，可以在一个方法之中进行一些结构的拆分，以防止相同变量名称所带来的互相影响。

（2）构造代码块

​		构造块是定义在一个类之中的

```java
class Person{
    public Person(){
        System.out.println("【构造方法】Person类构造方法执行");
    }
    { // 构造代码块，会优先于 构造方法 先执行
        System.out.println("【构造块】Person类构造块执行");
    }
}

public class JavaDemo {
    public static void main(String[] args) {
        new Person();
        new Person();
    }
}
// 输出结果   
【构造块】Person类构造块执行
【构造方法】Person类构造方法执行
【构造块】Person类构造块执行
【构造方法】Person类构造方法执行
```

​		构造块会优先于构造方法执行，并且每一次实例化新对象的时候都会调用构造块中的代码

（3）静态代码块

​		静态代码块的定义需要考虑到两种情况：非主类中定义静态代码块、主类中定义静态代码块

​	（3.1）在非主类中进行静态块的定义

```java
class Person{
    public Person(){
        System.out.println("【构造方法】Person类构造方法执行");
    }
    {
        System.out.println("【构造块】Person类构造块执行");
    }
    static {
        System.out.println("【静态块】Person类静态代码块执行");
    }
}

public class JavaDemo {
    public static void main(String[] args) {
        new Person();
        new Person();
        new Person();
    }
}
// 执行结果
【静态块】Person类静态代码块执行
【构造块】Person类构造块执行
【构造方法】Person类构造方法执行
【构造块】Person类构造块执行
【构造方法】Person类构造方法执行
【构造块】Person类构造块执行
【构造方法】Person类构造方法执行
```

​		此时可以发现==静态代码块会优先于构造块和构造方法先执行==，并且不管有多少个实例化对象出现，静态代码块==只会执行一次==，静态代码块的主要目的是为类中的静态属性初始化

​	（3.2）在主类中的静态代码块

```java
public class JavaDemo {
    static {
        System.out.println("*******************");
    }
    public static void main(String[] args) {
        System.out.println("主方法执行的内容");
    }
}
// 执行结果
*******************
主方法执行的内容
```

​		==静态代码块优先于主方法先执行==

# 7.数组

* **编写一个工具类实现数组的倒置**

  ```java
  class ArrayUtil{
      public static void reverse(int[] arr){
          int tail = arr.length-1;
          if(tail<0) {
              System.out.println("数组长度为0");
              return;
          }
          int head = 0;
          int center = arr.length/2;
          for(int i=0; i<center; i++){
              int temp = arr[head];
              arr[head] = arr[tail];
              arr[tail] = temp;
              head++;
              tail--;
          }
      }
  }
  
  public class JavaDemo {
      public static void main(String[] args) {
          int[] arr = new int[]{1,2,3,4,5,6,7,8,9,10};
          ArrayUtil.reverse(arr);
          for(int num: arr){
              System.out.print(num+" ");
          }
      }
  }
  
  ```

* **数组相关类库**

  ```java
  java.util.Arrays.sort();
  System.arraycopy(源数组，源数组开始点，目标数组，目标数组开始点，拷贝长度);
  ```

* **方法可变参数**

  ```java
  class ArrayUtil{
      // 可变参数的写法 ...   本质是一个数组
      public static int sum(int ... data){
          int sum = 0;
          for(int temp: data){
              sum += temp;
          }
          return sum;
      }
  }
  
  public class JavaDemo {
      public static void main(String[] args) {
          System.out.println(ArrayUtil.sum(1,2,3,4,5,6,7,8,9,10));
      }
  }
  ```

  ​	可变参数的最大作用在于，在以后进行一些程序类设计或者开发者调用的时候，利用此种形式就可以避免数组的传递操作了，但是可变参数的本质需要清楚的是：依然是数组