[toc]



# 一、多线程

## 1.1 多线程编程

### 1.1.1 **继承Thread类实现多线程**

```java
class MyThread extends Thread{
    private String title;
    public MyThread(String title){
        this.title = title;
    }

    @Override
    public void run() {
        for(int x = 0; x<10; x++){
            System.out.println(this.title + "运行，x=" + x);
        }
    }
}

class ThreadDemo{
    public static void main(String[] args) {
        new MyThread("线程A").start();	// 这里如果使用run方法，三个线程是顺序执行的，并没有并行执行
        new MyThread("线程B").start();
        new MyThread("线程C").start();
    }
}
```

​	虽然调用的是start()方法，但最终执行的是run()方法，并且所有的线程对象都是交替执行的，执行顺序是不可控的。为什么多线程的启动不直接使用run()方法，而必须使用Thread类中的start()方法呢？

​	在Java程序的执行过程之中，考虑到对于不同层次开发者的需求，所以其支持有本地的操作系统函数调用，而这项技术被称为JNI（Java Native Interface），但是Java开发过程之中并不推荐这样使用，利用这项技术可以使用一些操作系统提供的底层函数进行一些特殊的处理，而在Thread类里面提供的`start0()` 就表示需要将此方法依赖于不同的操作系统实现。



### 1.1.2 基于Runnable接口实现多线程



### 1.1.3 Thread 与 Runnable 的关系

<img src="../../images/高级特性/image-20200929174633701.png" alt="image-20200929174633701" style="zoom:67%;" />

​	例子：利用卖票程序来实现多个线程的资源并发访问

```java
class MyThread implements Runnable{
    private int ticket = 5;
    @Override
    public void run(){
        for(int x=0; x<100; x++){
            if(this.ticket > 0){
                System.out.println("卖票，ticket = " + this.ticket--);
            }
        }
    }
}

class Example{
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        new Thread(mt).start();         // 第一个线程启动
        new Thread(mt).start();         // 第二个线程启动
        new Thread(mt).start();         // 第三个线程启动
    }
}
```



### 1.1.4 Callable 实现多线程

​	Runnable接口有一个缺点：当线程执行完毕之后，无法获取一个返回值。从JDK1.5之后提出了一个新的线程实现接口：java.util.concurrent.Callable接口

```java
public interface Callable<V>{
    public V call() throws Excetion;
}
```

​	可以发现Callable定义的时候可以设置一个泛型，此泛型的类型就是返回数据的类型，这样的好处是可以避免向下转型带来的安全隐患。

<img src="../../images/高级特性/image-20200929182745902.png" alt="image-20200929182745902" style="zoom:50%;" />

* **示例：**

  使用Callable实现多线程

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class MyThread implements Callable<String>{
    @Override
    public String call() throws Exception{
        for(int x=0; x<10; x++){
            System.out.println("********* 线程执行" + x);
        }
        return "线程执行完毕";
    }
}

class Example{
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<String> task = new FutureTask<>(new MyThread());
        new Thread(task).start();
        System.out.println("【线程返回数据】" + task.get());
    }
}
```

* **面试题：请解释Runnable与Callable的区别？**

  java.lang.Runnable 接口之中只提供有一个run()方法，并且没有返回值

  java.util.concurrent.Callable接口提供有Call()方法，可以有返回值



### 1.1.5 线程运行状态

<img src="../../images/高级特性/image-20200929183933815.png" alt="image-20200929183933815" style="zoom:67%;" />



## 1.2 线程常用操作方法

### 1.2.1 线程的命名与取得

​	多线程的运行状态是不确定的，那么在程序的开发之中为了可以获取到一些需要使用的线程就只能够依靠线程的名字来进行操作。所以线程的名字是一个至关重要的概念，这样在Thread类之中就提供有线程名称的处理。

|          |                                             |
| -------- | ------------------------------------------- |
| 构造方法 | public Thread(Runnable target, String name) |
| 设置名字 | public final void setName(String name)      |
| 取得名字 | public final String getName()               |



### 1.2.2 线程的休眠

| 方法定义                                                     |
| ------------------------------------------------------------ |
| public static void sleep(long millis) throws InterruptedExcetion |
| public static void sleep                                     |

​	在进行休眠的时候可能会产生中断异常`InterruptedExcetion`，中断异常属于Exception的子类，所以证明该异常必须进行处理。

```java
class Demo{
    public static void main(String[] args) {
        new Thread(()->{
           for(int x=0; x<10; x++){
               System.out.println(Thread.currentThread().getName() + "、x=" + x);
               try {
                   Thread.sleep(1000);      // 暂缓执行
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
        },"线程对象").start();
    }
}
```

​	休眠的主要特点是可以自动进行线程的唤醒，以继续进行后续的处理。但是需要注意的是，如果现在你有多个线程对象，那么休眠也是有先后顺序的。

* **示例：产生多个线程对象进行休眠**

```java
public class Demo {
    public static void main(String[] args) {
        Runnable run = ()->{
            for(int x=0; x<10; x++){
                System.out.println(Thread.currentThread().getName() + "、x=" + x);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        for(int num=0; num<5; num++){
            new Thread(run, "线程对象-" + num).start();			// 产生五个线程对象
        }
    }
}
```

​	此时将产生5个线程对象，并且这五个线程对象执行的方法体是相同的。此时从程序执行的感觉上来讲，好像是若干个线程一起进行了休眠，而后一起进行了自动唤醒，但是实际上是有差别的。

<img src="../../images/高级特性/image-20201010101303104.png" alt="image-20201010101303104" style="zoom:67%;" />



### 1.2.3 线程中断

​	某个线程的中断是由其它线程完成的，在Thread类中提供有两种中断执行的处理方法：

> * 判断线程是否被中断：public boolean isInterrupted()
> * 中断线程执行：public void interrupt()

* **示例：线程中断的处理操作**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Thread thread = new Thread(()->{
              System.out.println("***线程启动***");
              try{
                  Thread.sleep(10000);
                  System.out.println("***线程执行完毕***");
              }catch (InterruptedException e){
                  e.printStackTrace();
              }
          });
          thread.start();
          if(!thread.isInterrupted()){    // 判断线程是否中断，如果没有中断，则执行线程的中断操作
              thread.interrupt();         // 中断线程的执行
          }
      }
  }
  ```

  ​	执行结果：

  <img src="../../images/高级特性/image-20201010105053133.png" alt="image-20201010105053133" style="zoom:67%;" />

  所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理。



### 1.2.4 线程强制运行

​	所谓的线程的强制执行指的是当满足某些条件之后，某一个线程对象将可以一直独占资源，一直到该线程的程序执行结束。线程的强制执行可以使用Thread中提供的方法：`join()`

* **示例：观察一个没有强制执行的程序**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Thread thread = new Thread(()->{
              for(int x=0; x<100; x++){
                  try {
                      Thread.sleep(100);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "执行、x=" + x);
              }
          },"玩耍的线程");
          thread.start();
          for(int x=0; x<100; x++){
              Thread.sleep(100);
              System.out.println("【霸道的main线程】number=" + x);
          }
      }
  }
  ```

  ​	以上程序代码，主线程和子线程在交替执行着，但是如果希望主线程独占执行，那么可以使用Thread类中的方法：强制执行。

* **线程强制执行的程序**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Thread mainThread = Thread.currentThread();     // 获得主线程
          Thread thread = new Thread(()->{
              for(int x=0; x<100; x++){
                  if(x==3){       // 现在霸道的线程要来了
                      try {
                          mainThread.join();      // 霸道线程要先执行
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                  }
                  try {
                      Thread.sleep(100);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "执行、x=" + x);
              }
          },"玩耍的线程");
          thread.start();
          for(int x=0; x<100; x++){
              Thread.sleep(100);
              System.out.println("【霸道的main线程】number=" + x);
          }
      }
  }
  ```

  ​	在进行线程强制执行的时候，一定要获取强制执行线程对象之后，才可以执行`join()`的调用。



### 1.2.5 线程礼让

​	线程的礼让指的是先将资源让出去，让别的线程先执行。线程的礼让可以使用Thread中提供的方法：`public static void yield()`

* **示例：线程的礼让操作**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Thread thread = new Thread(()->{
              for(int x=0; x<100; x++){
                  if(x%3 == 0){
                      Thread.yield(); // 线程礼让
                      System.out.println("### 玩耍的线程礼让执行 ###");
                  }
                  try {
                      Thread.sleep(100);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "执行、x=" + x);
              }
          },"玩耍的线程");
          thread.start();
          for(int x=0; x<100; x++){
              Thread.sleep(100);
              System.out.println("【霸道的main线程】number=" + x);
          }
      }
  }
  ```



### 1.2.6 线程优先级

​	从理论上说，线程的优先级越高越有可能先执行（越有可能先抢占到资源）。Thread类中针对优先级操作提供有以下两个处理方法：

| 功能       | 方法                                           |
| ---------- | ---------------------------------------------- |
| 设置优先级 | public final void setPriority(int newPriority) |
| 获取优先级 | public final int getPriority()                 |

​	在进行优先级定义的时候都是通过int型的数字来完成的，而对于此数字的选择在Thread类中定义有三个常量：

| 功能       | 常量                                  |
| ---------- | ------------------------------------- |
| 最高优先级 | public static final int MAX_PRIORITY  |
| 中等优先级 | public static final int NORM_PRIORITY |
| 最低优先级 | public static final int MIN_PRIORITY  |

* **示例：线程优先级操作**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Runnable run = ()->{
              for(int x=0; x<10; x++){
                  try {
                      Thread.sleep(1000);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "执行。");
              }
          };
          Thread threadA = new Thread(run, "线程对象A");
          Thread threadB = new Thread(run, "线程对象B");
          Thread threadC = new Thread(run, "线程对象C");
          threadA.setPriority(Thread.MAX_PRIORITY);
          threadB.setPriority(Thread.MIN_PRIORITY);
          threadC.setPriority(Thread.MIN_PRIORITY);
          threadA.start();
          threadB.start();
          threadC.start();
      }
  }
  ```

  ​	以上程序，A有较大概率先执行，但并不是每次都最先执行。即优先级高的线程有可能先执行，并不是绝对会先执行。



## 1.3 线程同步与死锁

​	在多线程的处理中，可以利用Runnable描述多个线程操作的资源，而Thread描述每一个线程对象，于是当多个线程访问同一资源的时候，如果处理不当，就会产生数据的错误操作。

### 1.3.1 同步问题的引出

​	下面编写一个简单的卖票程序，将创建若干个线程对象实现卖票的处理操作。

```JAVA
class MyThread implements Runnable{
    private int ticket = 10; //总票数为10张
    @Override
    public void run() {
        while(true){
            if(this.ticket>0){
                try {
                    Thread.sleep(100);      // 模拟网络延迟
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "卖票，ticket = " + this.ticket --);
            } else{
                System.out.println("*** 票已售罄 ***");
                break;
            }
        }
    }
}

class Demo{
    public static void main(String[] args) throws Exception {
        MyThread myThread = new MyThread();
        new Thread(myThread, "票贩子A").start();
        new Thread(myThread, "票贩子B").start();
        new Thread(myThread, "票贩子C").start();
    }
}
```

​	由于手动添加了线程休眠来模拟网络延迟的情况，以上程序在多次运行中可能出现剩余票数为-1的情况，程序运行过程如下：

<img src="../../images/高级特性/image-20201010143442591.png" alt="image-20201010143442591" style="zoom:67%;" />



### 1.3.2 线程同步处理

​	解决同步问题的关键在于锁。锁指的是当某一个线程执行操作的时候，其它线程在外面等着。

<img src="../../images/高级特性/image-20201010143959035.png" alt="image-20201010143959035" style="zoom:67%;" />

​	如果想在程序之中实现这把锁的功能，就可以使用synchronized关键字来实现，利用此关键字可以定义同步方法或同步代码块，在同步代码块的操作里面的代码只允许一个线程执行。

* **利用同步代码块进行处理**

  ```java
  synchronized(同步对象){
      同步代码操作;
  }
  ```

  ​	一般要进行同步对象处理的时候可以采用当前对象this进行同步

  * 示例：利用同步代码块解决数据同步访问问题

    ```java
    class MyThread implements Runnable{
        private int ticket = 10000;
        @Override
        public void run() {
            while(true){
                synchronized (this){        // 每次只允许一个线程进行访问
                    if(this.ticket>0){
                        try {
                            Thread.sleep(1);      // 模拟网络延迟
                        }catch (InterruptedException e){
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "卖票，ticket = " + this.ticket --);
                    } else{
                        System.out.println("*** 票已售罄 ***");
                        break;
                    }
                }
            }
        }
    }
    
    class Demo{
        public static void main(String[] args) throws Exception {
            MyThread myThread = new MyThread();
            new Thread(myThread, "票贩子A").start();
            new Thread(myThread, "票贩子B").start();
            new Thread(myThread, "票贩子C").start();
        }
    }
    ```

* **利用同步方法解决：只需要在方法定义上使用synchronized关键字即可**

  ```java
  class MyThread implements Runnable{
      private int ticket = 10;
  
      public synchronized boolean sale(){
          if(this.ticket>0){
              try {
                  Thread.sleep(100);      // 模拟网络延迟
              }catch (InterruptedException e){
                  e.printStackTrace();
              }
              System.out.println(Thread.currentThread().getName() + "卖票，ticket = " + this.ticket --);
              return true;
          } else{
              System.out.println("*** 票已售罄 ***");
              return false;
          }
      }
  
      @Override
      public void run() {
          while(this.sale()){
          }
      }
  }
  
  class Demo{
      public static void main(String[] args) throws Exception {
          MyThread myThread = new MyThread();
          new Thread(myThread, "票贩子A").start();
          new Thread(myThread, "票贩子B").start();
          new Thread(myThread, "票贩子C").start();
      }
  }
  ```



## 1.4 经典示例(生产者消费者)

​		在多线程的开发过程中，最为著名的案例是生产者与消费者操作，该操作的主要流程如下：

> * 生产者负责信息内容的生产
>
> * 每当生产者生产完成一项完整的信息之后消费者要从这里面取走信息
>
> * 如果生产者没有生产则消费者要等待它生产完成，如果消费者还没有对信息进行消费，则生产者应该等待消费处理完成后再继续生产。

<img src="../../images/高级特性/image-20201010170059452.png" alt="image-20201010170059452" style="zoom:67%;" />

* **程序的基本实现**

  ​	可以将生产者与消费者定义为两个独立的线程类对象，但是对于现在生产的数据，可以使用如下的组成：

  > * 数据一：title = 张大、content = 家中老大
  > * 数据二：title = 张二、content = 家中老二

  ​	既然生产者与消费者是两个独立的线程，那么这两个独立的线程之间就需要有一个数据保存的集中点，那么可以单独定义一个Message类来进行数据的保存

  ```java
  // 生产者
  class Producer implements Runnable{
      private Message msg;
      public Producer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              if(x%2 == 0){
                  this.msg.setTitle("张大");
                  try{
                      Thread.sleep(100);
                  } catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  this.msg.setContent("家中老大");
              }else{
                  this.msg.setTitle("张二");
                  try{
                      Thread.sleep(100);
                  } catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  this.msg.setContent("家中老二");
              }
          }
      }
  }
  
  // 消费者
  class Consumer implements Runnable{
      private Message msg;
      public Consumer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              try{
                  Thread.sleep(10);
              } catch (InterruptedException e){
                  e.printStackTrace();
              }
              System.out.println(this.msg.getTitle() + "   -   " + this.msg.getContent());
          }
      }
  }
  
  // 保存的数据
  class Message{
      private String title;
      private String content;
  
      public void setTitle(String title) {
          this.title = title;
      }
      public void setContent(String content) {
          this.content = content;
      }
      public String getTitle() {
          return title;
      }
      public String getContent() {
          return content;
      }
  }
  
  // 主方法
  class Demo{
      public static void main(String[] args) throws Exception {
          Message msg = new Message();
          new Thread(new Producer(msg)).start();      // 启动生产者线程
          new Thread(new Consumer(msg)).start();      // 启动消费者线程
      }
  }
  ```

  ​	通过整个代码的执行会发现此时有两个主要问题：

  > 问题一：数据不同步（出现了“张大-家中老二”和“张二-家中老大”的记录）
  >
  > 问题二：应该是生产一个取走一个，但是发现有了重复生产和重复取出的问题

* **解决数据同步的问题**

  ​	如果要想解决数据同步，最简单的做法是使用synchronized关键字定义同步代码块或同步方法，于是这个时候对于同步的处理就可以直接在Message类中完成。

  ```java
  class Producer implements Runnable{
      private Message msg;
      public Producer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              if(x%2 == 0){
                  this.msg.set("张大", "家中老大");
              }else{
                  this.msg.set("张二", "家中老二");
              }
          }
      }
  }
  
  class Consumer implements Runnable{
      private Message msg;
      public Consumer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              System.out.println(this.msg.get());
          }
      }
  }
  
  class Message{
      private String title;
      private String content;
  
      public synchronized void set(String title, String content){		// 同步方法
          this.title = title;
          try{
              Thread.sleep(100);
          } catch (InterruptedException e){
              e.printStackTrace();
          }
          this.content = content;
      }
      public synchronized String get(){				// 同步方法
          try{
              Thread.sleep(100);
          } catch (InterruptedException e){
              e.printStackTrace();
          }
          return this.title + "   -   " + this.content;
      }
  }
  
  class Demo{
      public static void main(String[] args) throws Exception {
          Message msg = new Message();
          new Thread(new Producer(msg)).start();      // 启动生产者线程
          new Thread(new Consumer(msg)).start();      // 启动消费者线程
      }
  }
  ```
  
  ​	上面程序的执行结果：数据已经可以保持一致了（不再出现“张大-家中老二”和“张二-家中老大”的情况），但是对于重复操作的问题依然存在。

* **线程等待与唤醒**

  ​	如果要解决生产者与消费者问题，最好的解决方案是使用等待与唤醒机制。而对于等待与唤醒的机制，主要依赖Object类中提供的方法处理：

  | 功能         | 方法                                                         |
  | ------------ | ------------------------------------------------------------ |
  | 等待         | public final void wait() throws InterruptedException         |
  | 设置等待时间 | public final void wait(long timeout) throws InterruptedExption |
  | 设置等待时间 | public final void wait(long timeout, int nanos) throws InterruptedExption |

  | 功能               | 方法                          |
  | ------------------ | ----------------------------- |
  | 唤醒第一个等待线程 | public final void notify()    |
  | 唤醒全部等待线程   | public final void notifyAll() |

  ​	对于当前的问题主要的解决方法应该通过Message类完成

  ```java
  class Producer implements Runnable{
      private Message msg;
      public Producer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              if(x%2 == 0){
                  this.msg.set("张大", "家中老大");
              }else{
                  this.msg.set("张二", "家中老二");
              }
          }
      }
  }
  
  class Consumer implements Runnable{
      private Message msg;
      public Consumer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              System.out.println(this.msg.get());
          }
      }
  }
  
  class Message{
      private String title;
      private String content;
      private boolean flag = true;       // 表示生产或消费的形式
      // flag = true;             // 允许生产，不允许消费
      // flag = false;            // 允许消费，不允许生产
      public synchronized void set(String title, String content){
          if(this.flag == false){         // 无法进行生产，应该等待被消费
              try{
                  super.wait();
              } catch (InterruptedException e){
                  e.printStackTrace();
              }
          }
          this.title = title;
          try{
              Thread.sleep(100);
          } catch (InterruptedException e){
              e.printStackTrace();
          }
          this.content = content;
          this.flag = false;          // 已经生产过了
          super.notify();             // 生产完成后，也有可能存在等待的消费者，所以这里唤醒等待的线程（有就唤醒，没有就什么也不做）
      }
      public synchronized String get(){
          if(this.flag == true){      // 还未生产，需要等待
              try{
                  super.wait();
              } catch (InterruptedException e){
                  e.printStackTrace();
              }
          }
          try{
              Thread.sleep(100);
          } catch (InterruptedException e){
              e.printStackTrace();
          }
          try{
              return this.title + "   -   " + this.content;
          } finally {     // 不管如何都要执行
              this.flag = true; // 继续生产
              super.notify();     // 唤醒等待线程
          }
  
      }
  }
  
  class Demo{
      public static void main(String[] args) throws Exception {
          Message msg = new Message();
          new Thread(new Producer(msg)).start();      // 启动生产者线程
          new Thread(new Consumer(msg)).start();      // 启动消费者线程
      }
  }
  ```

  ​	这种处理形式就是在进行多线程开发过程之中最原始的处理方案，整个的等待、同步、唤醒机制都由开发者自行通过原生代码实现控制。



## 1.5 多线程深入

### 1.5.1 优雅的停止线程

​	多线程如果需要进行停止处理，Thread类原本提供有stop()方法，但是对于这些方法从jdk1.2开始就已经将其废除了，而且一直到现在也不再建议出现在代码之中，除了stop()方法之外，也有几个方法被废除了：

> 停止多线程：public void stio()
>
> 销毁多线程：public void destroy()
>
> 挂起线程：public final void suspend()、暂停执行
>
> 恢复挂起的线程执行：public final void resume()

​	之所以废除这些方法，主要原因是因为这些方法有可能导致线程死锁，所以从jdk1.2开始就不建议使用了。如果这个时候要实现线程的停止需要通过一种柔和的方式来进行。

* **示例：实现线程柔和的停止**

  ```java
  public class Demo {
      public static boolean flag = true;
  
      public static void main(String[] args) throws InterruptedException {
          new Thread(()->{
              long num = 0;
              while(flag){
                  try {
                      Thread.sleep(5);
                  } catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "正在运行、num = " + num++);
              }
          }, "执行线程").start();
          Thread.sleep(20);	// 运行20毫秒
          flag = false;	// 停止线程
      }
  }
  ```

  ​	通过其它的线程去控制flag的内容，那么这个时候对于线程的停止也不是说停就立刻停止的，而是会在执行中判断flag的内容来完成。



### 1.5.2 后台守护线程

| 功能               | 方法                                    |
| ------------------ | --------------------------------------- |
| 设置为守护线程     | public final void setDaemon(boolean on) |
| 判断是否为守护线程 | public final boolean isDaemon()         |

```java
public class Demo {
    public static boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        Thread userThread = new Thread(()->{
            for(int x=0; x<10; x++){		// 核心业务线程执行10次
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在运行、x = " + x);
            }
        }, "用户线程");     // 完成核心的业务

        Thread daemoThread = new Thread(()->{
            for(int x=0; x<Integer.MAX_VALUE; x++){
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在运行、x = " + x);
            }
        }, "守护线程");     // 完成核心的业务

        daemoThread.setDaemon(true);    // 设置为守护线程
        userThread.start();
        daemoThread.start();
    }
}
```

​	可以发现所有的守护线程都是围绕在用户线程周围，如果程序执行完毕了，守护线程也就消失了，在整个的JVM里面最大的守护线程就是GC线程。

​	程序执行中GC线程会一直存在，如果程序执行完毕，GC线程也将消失。



### 1.5.3 volatile关键字

​	在多线程的定义之中，volatile关键字主要是在属性定义上使用的，表示此属性为直接数据操作，而不进行副本的拷贝处理，这样在一些书上就将其错误的理解为同步属性了。

​	在正常进行变量处理的时候往往会经历如下的几个步骤：

> * 获取变量原有的数据内容副本
> * 利用副本为变量进行数学计算
> * 将计算后的变量，保存到原始空间之中

​	而如果一个属性上追加了volatile关键字，表示的就是<u>不使用副本，而是直接操作原始变量</u>，相当于节约了：拷贝副本、重新保存的步骤。

* **面试题：请解释volatile与synchronized的区别**

  > * volatile 主要在属性上使用，而synchronized是在代码块与方法上使用的
  > * volatile 无法描述同步的处理，它只是一种直接内存的处理，避免了副本的操作



## 1.6 多线程综合案例

* **案例一：**设计一个生产电脑和搬运电脑的类，要求生产一台电脑就搬走一台电脑，如果没有新的电脑生产出来，则搬运工要等待新电脑产出；如果生产出的电脑没有搬走，则要等待电脑搬走之后再生产，并统计生产出的电脑数量。

  ```java
  // 生产者
  class Producer_1 implements Runnable{
      private Resource resource;
      public Producer_1(Resource resource){
          this.resource = resource;
      }
      @Override
      public void run() {
          for(int x=0; x<50; x++){
              try {
                  this.resource.make();
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }
      }
  }
  
  // 消费者
  class Consumer_1 implements Runnable{
      private Resource resource;
      public Consumer_1(Resource resource){
          this.resource = resource;
      }
      @Override
      public void run() {
          for(int x=0; x<50; x++){
              try {
                  this.resource.get();
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }
      }
  }
  
  class Resource{
      private Computer computer;
      public synchronized void make() throws Exception{
          if(this.computer != null){     // 已经生产过了
              super.wait();
          }
          Thread.sleep(100);
          this.computer = new Computer("Lenovon拯救者", 8999.0);
          System.out.println("【生产电脑】" + this.computer);
          super.notify();
      }
      public synchronized void get() throws Exception {
          if(this.computer == null){      // 没有生产过
              super.wait();
          }
          Thread.sleep(10);
          System.out.println("【取走电脑】" + this.computer);
          this.computer = null;
          super.notify();
      }
  }
  
  class Computer{
      private static int count = 0 ;     // 表示生产的电脑台数
      private String name;
      private double price;
      public Computer(String name, Double price){
          this.name = name;
          this.price = price;
          count++;
      }
      @Override
      public String toString(){
          return "【第" + count + "台电脑】" + "电脑名字：" + this.name + "、价值：" + this.price;
      }
  
  }
  
  public class Demo {
      public static void main(String[] args) throws InterruptedException {
          Resource resource = new Resource();
          new Thread(new Producer_1(resource)).start();
          new Thread(new Consumer_1(resource)).start();
      }
  }
  ```

* **案例二：**实现一个竞拍抢答程序，要求设置三个抢答者（三个线程），而后同时发出抢答指令，抢答成功给出成功提示，未抢答成功给出失败提示。

  分析：该案例的多线程操作涉及到数据的返回问题，所以最好使用Callable进行实现。

  ```JAVA
  import java.util.concurrent.Callable;
  import java.util.concurrent.FutureTask;
  
  class MyThread implements Callable<String>{
      private boolean flag = false;
      @Override
      public String call() throws Exception {
          synchronized (this){
              if(this.flag == false){
                  this.flag = true;
                  return Thread.currentThread().getName() + "抢答成功！";
              }
              else {
                  return Thread.currentThread().getName() + "抢答失败！";
              }
          }
      }
  }
  
  public class Demo {
      public static void main(String[] args) throws Exception {
          MyThread mt = new MyThread();
          FutureTask<String> taskA = new FutureTask<>(mt);
          FutureTask<String> taskB = new FutureTask<>(mt);
          FutureTask<String> taskC = new FutureTask<>(mt);
          new Thread(taskA, "竞赛者A").start();
          new Thread(taskB, "竞赛者B").start();
          new Thread(taskC, "竞赛者C").start();
          System.out.println(taskA.get());
          System.out.println(taskB.get());
          System.out.println(taskC.get());
      }
  }
  ```

# 二、Java常用类库

## 2.1 StringBuffer

​	String 类拥有如下的特性：

> * 每个字符串的常量都属于一个 String 类的匿名对象，并且不可更改
> * String 有两个常量池：静态常量池、运行时常量池
> * String 类对象实例化建议使用直接赋值的形式完成， 这样可以直接将对象保存在对象池中中以方便下次重用

​	虽然 String 类很好使用，但是其最大的弊端：内容不允许修改。为了解决此问题，专门提供有一个 StringBuffer 类可以实现字符串内容的修改处理。

​	StringBuffer 并不像 String 类那样拥有两种对象的实例化方式，StringBuffer 必须像普通类那样首先对象实例化，而后才可以调用方法执行处理，而这个时候可以考虑使用StringBuffer类中的如下方法：

> 构造方法：pubilc StringBuffer()
>
> 构造方法：public StringBuffer(String str)，接受初始化字符串内容
>
> 数据追加：public StringBuffer append(数据类型 变量)，相当于字符串中的“+”操作

​	StringBuffer类中除了可以支持字符串内容的修改之外，实际上也提供有一些 String 类所不具备的方法：

> 插入数据：public StringBuffer insert(int offset, 数据类型 b)
>
> 删除指定范围的数据：public StringBuffer delete(int start, int end)
>
> 字符串内容反转：public StringBuffer reverse()

​	实际上与 StringBuffer 类还有一个类似的功能类：StringBuilder 类，这个类是在 JDK1.5 开始提供的，该类中提供的方法与 StringBuffer 功能相同，最大的区别在于 StringBuffer类中的方法属于线程安全，全部使用了 synchronized 关键字进行标注，而 StringBuilder 类属于非线程安全。



## 2.2 CharSequence 接口

​	`CharSequence`是一个描述字符串结构的接口，在这个接口中一般有三种常用子类：

| String类                                                     | StringBuffer类                                               | StringBuilder类                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| public final class String extends Object implements Serializable, Comparable<String>, <u>CharSequence</u> | public final class StringBuffer extends Object implements Serializable, <u>CharSequence</u> | public final class StringBuilder extends Object implements Serializable, <u>CharSequence</u> |

<img src="../../images/高级特性/image-20201020184550863.png" alt="image-20201020184550863" style="zoom:67%;" />

​	现在只要有字符串，就可以为CharSequence接口实例化

​	CharSequence本身也是一个接口，在该接口中也定义有如下的操作方法：

> * 获取指定索引字符：public char charAt(int index)
> * 获取字符串的长度：public int length()
> * 截取部分字符串：public CharSequence subSequence(int start, int end)



## 2.3 AutoCloseable接口

​	`AutoCloseable`主要是用于日后进行资源开发的处理上，以实现资源的自动关闭（释放资源），例如，在以后进行文件、网络、数据库开发的过程之中，由于服务器的资源有限，所以使用之后一定要关闭资源，这样做才可以被更多的使用者使用。

​	该接口在JDK1.7时提出，并且该接口只提供有一个方法：

```java
public void close() throws Exception
```

​	要想实现自动关闭处理，除了要使用AutoCloseable之外，<u>==还需要结合异常处理语句才可以完成资源的自动关闭==</u>

```java
public class Demo {
    public static void main(String[] args) throws Exception {
        try (IMessage nm = new NetMessage("www.pcr.com")){
            nm.send();          // 不用显示调用close方法也能关闭资源
        } catch (Exception e){

        }
    }
}

interface IMessage extends AutoCloseable{
    public void send();     // 消息发送
}

class NetMessage implements IMessage{
    private String msg;
    public NetMessage(String msg){
        this.msg = msg;
    }
    public boolean open(){
        System.out.println("【OPEN】获取消息发送连接资源。");
        return true;
    }
    @Override
    public void send(){
        if(this.open()){
            System.out.println("【*** 发送消息 ***】" + this.msg);
        }
    }
    @Override
    public void close() throws Exception{
        System.out.println("【Close】关闭消息发送通道");
    }
}
```



## 2.4 Runtime类

​	Runtime描述的是运行时的状态，也就是说在整个的JVM之中，Runtime类是唯一一个与JVM运行状态有关的类，并且都会默认提供一个该类的实例化对象。

​	由于在每一个JVM进程里面只允许有一个Runtime类的对象，所以这个类的构造方法被默认私有化了，那么就证明该类使用的是单例设计模式，并且单例设计模式一定会提供有一个static方法获取本类的实例。

<img src="../../images/高级特性/image-20201020191944728.png" alt="image-20201020191944728" style="zoom:67%;" />

​	由于Runtime类属于单例设计模式，如果要想获取实例化对象，那么就可以依靠类中的`getRuntime()`方法完成：获取实例化对象：public static Runtime getRuntime()

```java
public class Demo {
    public static void main(String[] args) throws Exception {
        Runtime rt = Runtime.getRuntime();      // 获取实例化对象
        System.out.println(rt.availableProcessors());
    }
}
// 通过该类中的availableProcessors()方法可以获取本机的CPU内核数量
```

​	除了以上的方法之外，在Runtime类中还提供有以下四个重要的操作方法：

| 功能                 | 方法                    |
| -------------------- | ----------------------- |
| 获取最大可用内存空间 | public long maxMemory   |
| 获取可用内存空间     | public long totalMemory |
| 获取空闲内存空间     | public long freeMemory  |
| 手工进行GC处理       | public void gc()        |



## 2.6 System类

| 功能                   | 方法                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 数组拷贝               | public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) |
| 获取当前的日期时间数值 | public static long currentTimeMillis()                       |
| 进行垃圾回收           | public static void gc()                                      |

* **示例：操作耗时的统计**

  ```java
  public class Demo {
      public static void main(String[] args) throws Exception {
          long start = System.currentTimeMillis();
          String str = "";
          for(int x=0; x<30000; x++){
              str += x;
          }
          long end = System.currentTimeMillis();
          System.out.println("操作耗时：" + (end-start));
      }
  }
  ```

* **gc()**

  等价于 `Runtime.getRuntime.gc()`



## 2.7 对象克隆

​	所谓的对象克隆指的就是对象的复制，而且属于全新的复制。即：使用已有对象内容创建一个新的对象，如果要进行对象的克隆，需要用到Object类中提供的`clone()`方法：`protected Object clone() throws CloneNotSupportedException`

​	所有的类都会继承Object类，所以所有的类都一定会有clone()方法，但是并不是所有的类都希望被克隆。所以要想实现对象的克隆，那么对象所在的类需要实现一个Cloneable接口，<u>此接口并没有任何的方法提供，是因为它描述的是一种能力</u>。

* **示例：实现对象克隆**

  ```java
  class Member implements Cloneable{
      private String name;
      private int age;
      public Member(String name, int age){
          this.name = name;
          this.age = age;
      }
      @Override
      public String toString() {
          return "【" + super.toString() + "】name = " + this.name + "、age = " + this.age;
      }
      @Override
      protected Object clone() throws CloneNotSupportedException {
          return super.clone();          // 调用父类中提供的clone()方法
      }
  }
  
  public class Demo {
      public static void main(String[] args) throws Exception {
          Member memberA = new Member("钢铁侠", 45);
          Member memberB = (Member) memberA.clone();
          System.out.println(memberA);
          System.out.println(memberB);
      }
  }
  ```

  ​	如果在开发之中，不是非常特别的需求下，很少会出现有对象克隆的需求。



## 2.8 数字操作类

### 2.8.1 Math数学计算类

​	Math类的主要功能是进行数学计算的操作类，提供有基础的计算公式。这个类的构造方法被私有化了（但不是单例），而且该类中提供的所有方法都是static型的方法，即：这些方法都可以通过类名称直接调用。

```java
public class Demo {
    public static void main(String[] args) {
        System.out.println(Math.abs(-10.1));
        System.out.println(Math.max(-10.1, 51));
        System.out.println(Math.log(53));
        System.out.println(Math.round(15.1));   //15
        System.out.println(Math.round(15.5));   //16
        System.out.println(Math.round(15.51));  //16
        System.out.println(Math.round(-15.1));  //-15
        System.out.println(Math.round(-15.5));  //-15
        System.out.println(Math.round(-15.51)); //-16
        System.out.println(Math.pow(2,8)); //256
    }
}
```

​	虽然在Math类中提供有四舍五入的处理方法，但是这个四舍五入在进行处理的时候，是直接将小数点后的所有位进行进位处理了，这样不方便，我们可以实现指定位数的保留：

```java
class MathUtil {
    private MathUtil(){}	// 构造函数私有化，这样该工具类不存在实例化对象

    /**
     * 实现数据的四舍五入操作
     * @param num   要进行四舍五入操作的数字
     * @param scale 四舍五入保留的小数位数
     * @return  四舍五入处理后的结果
     */
    public static double round(double num, int scale){
        return Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale);
    }
}

public class Demo {
    public static void main(String[] args) {
        System.out.println(MathUtil.round(19.454324, 3));
    }
}
```

​	Math类中提供的基本上都是基础的数学公式，需要的时候需要自己重新整合。



### 2.8.2 Random随机数生成类

​	java.util.Random类的主要功能是产生随机数，该类主要是依靠内部提供的方法来完成的：

| 功能                                                    | 方法                          |
| ------------------------------------------------------- | ----------------------------- |
| 产生一个不大于边界的随机整数（0和正整数，不包含负整数） | public int nextInt(int bound) |

```java
import java.util.Random;

public class Demo {
    public static void main(String[] args) {
        Random random = new Random();
        for(int x=0; x<100; x++){
            System.out.print(random.nextInt(10) + "、");
        }
    }
}
```



### 2.8.3 大数字处理类

​	在进行数学计算的工程中，还有一个大数字的操作类，可以实现海量数字的计算（能提供的也只是基础计算）：BigInteger、BigDecimal

<img src="../../images/高级特性/image-20201020205344716.png" alt="image-20201020205344716" style="zoom:50%;" />

​	BigInteger类构造：public BigInteger(String val)

​	BigDecimal类构造：public BigDecimal(String val)

* **示例：使用BigInteger实现四则运算**

  ```java
  import java.math.BigInteger;
  
  public class Demo {
      public static void main(String[] args) {
          BigInteger bigA = new BigInteger("454531324657465413644165423100454341354513246541564");
          BigInteger bigB = new BigInteger("74434113545415645401231544541546516547554123");
          System.out.println("加法操作：" + bigA.add(bigB));
          System.out.println("减法操作：" + bigA.subtract(bigB));
          System.out.println("乘法操作：" + bigA.multiply(bigB));
          System.out.println("除法操作：" + bigA.divide(bigB));
      }
  }
  ```




## 2.9 日期操作类

### 2.9.1 Date 日期处理类

​	java.util.Date

​	将 long 转为 Date: public Date(long date)

​	将 Date 转为 long: public long getTime()

* **示例：Date与 long 之间的转换**

  ```java
  import java.util.Date;
  
  public class Demo {
      public static void main(String[] args) {
          Date date = new Date();
          System.out.println(date);
          long current = date.getTime();
          current += 864000 * 1000;		// 10天的毫秒数
          System.out.println(new Date(current));		// long 转为 Date
      }
  }
  ```



### 2.9.2 日期的格式化处理——SimpleDateFormat日期处理类

​	默认情况下Date类输出的的日期时间结构并不能够被国人所习惯，需要对时间显示的格式进行格式化的处理，在`java.text`包中提供有 `SimpleDateFormat`程序类，该类中提供有如下方法：

| 功能                                 | 方法                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 构造方法                             | public SimpleDateFormat(String pattern)  日期格式：年（yyyy）、月（MM）、日（dd）、时（HH）、 分（mm）、秒（ss）、毫秒（SSS） |
| 【从DateFormat继承】将日期转为String | public final String format(Date date)                        |
| 【从DateFormat继承】将String转为日期 | public Date parse(String source) throws ParseException       |

<img src="../../images/高级特性/image-20201021102910877.png" alt="image-20201021102910877" style="zoom:35%;" />

* **示例：格式化日期显示**

  ```java
  import java.text.SimpleDateFormat;
  import java.util.Date;
  
  public class Demo {
      public static void main(String[] args) {
          Date date = new Date();
          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
          String str = sdf.format(date);		// format()，日期转为字符串
          System.out.println(str);
      }
  }
  // 输出：2020-10-21 10:12:39.540
  ```

  除了可以将日期格式化为字符串，也可以实现将字符串转化为日期

* **示例：将字符串转为日期**

  ```java
  import java.text.ParseException;
  import java.text.SimpleDateFormat;
  import java.util.Date;
  
  public class Demo {
      public static void main(String[] args) throws ParseException {
          String birthday = "1996-6-7 12:12:12.111";      // 字符串的日期
          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
          Date date = sdf.parse(birthday);	// parse(), 字符串转为日期
          System.out.println(date);
      }
  }
  // 输出：Fri Jun 07 12:12:12 CST 1996
  ```

  ​	如果在字符串定义时，所使用的日期时间超过了指定的合理范围，则会自动进行进位处理



## 2.10 正则表达式

​	通过之前的分析，String是一个非常万能的类型，因为String不仅仅可以支持各种字符串的处理操作，也支持向各个数据类型的转换功能，所以在项目的开发之中，只要是用户输入的信息，基本上都用String表示。于是在向其它数据类型转换的时候，为了保证转换的正确性，往往需要对其进行一些<u>复杂的验证处理</u>，那么这种情况下，如果只是单纯的依靠String类中的方法是非常麻烦的。

### 2.10.1 认识正则表达式

​	假设有一个字符串，要求判断该字符串是否由数字组成，如果由数字组成则将其变为数字，进行乘法计算。

```java
public class Demo {
    public static void main(String[] args) {
        String str = "123";
        if(str.matches("\\d+")){
            int num = Integer.parseInt(str);
            System.out.println(num*2);
        }
    }
}
```

​	正则表达式最早是从Perl语言中发展而来，而后在JDK1.4之前如果需要使用到正则表达式的相关定义，则需要单独引入其它的*.jar文件，但是从JDK1.4之后，正则已经默认被JDK所支持，并且提供有java.util.regex开发包，同时针对String类也进行了一些修改，使其可以有方法直接支持正则处理。



### 2.10.2 常用正则标记

1. **字符匹配【数量：单个】**
   * 任意字符：表示由任意字符组成
   * \\\：匹配“\”
   * \n：匹配换行
   * \t：匹配制表符

2. **字符集【数量：单个】**

   * [abc]: 表示可能是字母abc中的任意一个的单个字母

   * [^abc]:表示不是字母abc中的任意一个字母的单个字母

   * [a-zA-Z]: 表示由一个任意字母所组成，不区分大小写

   * [0-9]：表示任意一位数字

3. **简化的字符集【数量：单个】**

   * .：点（.）表示任意的一个字符
   * \d：等价于[0-9]，表示任意的一位数字
   * \D：等价于[ ^0-9]，表示任意的一个非数字的字符
   * \s：匹配任意的一位空格，可能是空格、换行或制表符
   * \S：匹配任意一位的非空格字符
   * \w：匹配任意字母、数字、下划线的单个字符，等价于[a-zA-Z_0-9]
   * \W：匹配任意非字符、数字、下划线的单个字符，等价于[ ^a-zA-Z_0-9]

4. **边界匹配**

   * ^：匹配边界开始
   * $：匹配边界结束

5. **数量表示**

   ​	默认情况下，只有添加上了数量单位才可以匹配多位字符

   * 表达式?：该正则可以出现0次或1次
   * 表达式*：该正则可以出现0次、1次或多次
   * 表达式+：该正则可以出现1次、多次
   * 表达式{n}：表达式的长度正好为n次
   * 表达式{n,}：表达式的长度为n次以上
   * 表达式{n,m}：表达式的长度在n~m次

6. **逻辑表达式：可以连接多个正则**

   * 表达式X表达式Y：X表达式之后紧跟Y表达式，两者同时满足才行
   * 表达式X|Y：有一个表达式满足即可
   * （表达式）：为表达式设置一个整体描述，可以为整体描述设置一个数量单位



### 2.10.3 String类对正则的支持

​	在进行正则表达式大部分处理的情况下，都会基于String类来完成，并且在String类中提供有如下与正则有关的操作方法：

| No.  | 方法名称                                                     | 类型 | 描述                     |
| ---- | ------------------------------------------------------------ | ---- | ------------------------ |
| 01   | public boolean matches(String regex)                         | 普通 | 将指定字符串进行正则判断 |
| 02   | public String replaceAll(String regex, String replacement)   | 普通 | 替换全部                 |
| 03   | public String replaceFirst(String regex, String replacement) | 普通 | 替换首个                 |
| 04   | public String[] split(String regex)                          | 普通 | 正则拆分                 |
| 05   | public String[] split(String regex, int limit)               | 普通 | 正则拆分，拆出指定个数   |

* **示例：实现字符串的替换（删除掉字符串中的非字母与数字）**

  ```java
  public class Demo {
      public static void main(String[] args) {
          String str = "dhg4q7i4yt98klajfo&^*&^(*&aog&%&^$%#$^_Hiohohiuh9&(^&hjh90";
          String regex = "[^a-zA-Z0-9]+";        // 匹配一位或多位的非数字和字母
          System.out.println(str.replaceAll(regex, ""));
      }
  }
  ```

* **示例：判断一个字符串是否由日期所组成，如果是由日期所组成，则将其转为Date类型**

  ```java
  import java.text.ParseException;
  import java.text.SimpleDateFormat;
  
  public class Demo {
      public static void main(String[] args) throws ParseException {
          String str = "2020-10-21";
          String regex = "\\d{4}-\\d{2}-\\d{2}";
          if(str.matches(regex)){
              System.out.println(new SimpleDateFormat("yyyy-MM-dd").parse(str));
          }
      }
  }
  ```

  ​	需要注意的是，正则表达式无法对里面的内容进行判断，只能够对格式进行判断处理

* **示例：判断给定的电话号码是否正确？**

  电话号码：4013433											\\\d{7,8}

  ​				 05634013433									(\\\d{3,4})?\\\d{7,8}

  ​				(0563)-4013433								((\\d{3,4})|(\\(\\d{3,4}\\)-))?\\d{7,8}

  ```java
  import java.text.ParseException;
  
  public class Demo {
      public static void main(String[] args) throws ParseException {
          String str = "(0563)-4013433";
          String regex = "((\\d{3,4})|(\\(\\d{3,4}\\)-))?\\d{7,8}";
          System.out.println(str.matches(regex));
      }
  }
  ```

* **示例：验证email格式**

  > * email 的用户名可以由字母、数字、_所组成（不应该使用“\_”开头）
  > * email 的域名可以由字母、数字、_、-所组成
  > * 域名的后缀必须是 .cn、.com、.net、.com.cn、.gov

  <img src="../../images/高级特性/image-20201021192525563.png" alt="image-20201021192525563" style="zoom:50%;" />

  ```java
  import java.text.ParseException;
  
  public class Demo {
      public static void main(String[] args) throws ParseException {
          String email = "chengruiPan@126-1.com";
          String regex = "[a-zA-Z0-9]\\w+@[a-zA-Z_0-9\\-]+\\.(cn|com|net|com.cn|gov)";
          System.out.println(email.matches(regex));
      }
  }
  ```



### 2.10.4  java.util.regex包支持

​	虽然在大部分情况下都可以利用String类实现正则的操作，但是也有一些情况下需要使用到 `java.util.regex` 开发包中提供的正则处理类。在该包中，一共定义有两个类：Pattern（正则表达式编译）、Matcher（正则表达式匹配）

* **Pattern 类**

  ​	Pattern 类提供有正则表达式的编译处理支持：public static Pattern complie(String regex)

  ​	同时也提供有字符串的拆分操作：public String[] split(CharSequence input)

  ```java
  import java.util.regex.Pattern;
  
  public class Demo {
      public static void main(String[] args) {
          String str = "gjkah(&()hjkhkjhi&()*_)&(^kjhhgiu5*^*(hjkklh";
          String regex = "[^a-zA-Z]+";
          Pattern pattern = Pattern.compile(regex);       // 编译正则表达式
          String[] result = pattern.split(str);
          for(String temp: result){
              System.out.println(temp);
          }
      }
  }
  ```

* **Matcher 类**

  ​	实现了正则匹配的处理类，这个类的对象实例化依靠Pattern类完成

  ​	Pattern 类提供的方法：public Matcher matcher(CharSequence input)

  ​	当获取了Matcher类的对象之后就可以利用该类中的方法进行如下操作：

  > * 正则匹配：public boolean matches()
  > * 字符串替换：public String replaceAll(String replacement)

  ```java
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;
  
  public class Demo {
      public static void main(String[] args) {
          String str = "101";
          String regex = "\\d+";
          Pattern pattern = Pattern.compile(regex);       // 编译正则表达式
          Matcher mat = pattern.matcher(str);
          System.out.println(mat.matches());
      }
  }
  ```

  ​	如果纯粹的是以<u>拆分、替换、匹配</u>三种操作为例，根本用不到java.util.regex开发包，只依靠String类就都可以实现了。但是Matcher类中提供有一种分组的功能，而这种分组的功能是String不具备的：

  ```java
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;
  
  public class Demo {
      public static void main(String[] args) {
          // 要求取出“#{内容}”标记中的所有内容
          String str = "INSERT INTO dept(deptno, dname, loc) VALUES (#{deptno}, #{dname}, #{loc})";
          String regex = "#\\{\\w+\\}";
          Pattern pat = Pattern.compile(regex);   // 编译正则表达式
          Matcher mat = pat.matcher(str);
          while(mat.find()) {             // 是否有匹配成功的内容
              System.out.println(mat.group(0).replaceAll("#|\\{|\\}", ""));
          }
      }
  }
  ```

  ​	java.util.regex 开发包，如果不是进行一些更为复杂的正则处理是很难使用到的，而String类所提供的功能只适合于正则的基本操作。



## 2.11 开发支持类库

### 2.11.1 UUID类

​	UUID 是一种生成无重复字符串的一个程序类，这个程序类的主要功能是根据时间戳实现一个自动的无重复的字符串定义。

​	获取UUID对象：public static UUID randomUUID()

​	根据字符串获取UUID内容：public static UUID fromString(String name)

```java
import java.util.UUID;

public class Demo {
    public static void main(String[] args) {
        System.out.println(UUID.randomUUID());	// UUID.randomUUID()返回的是UUID对象，打印时自动调用toString()方法
    }
}
```

​	在对一些文件进行自动命名处理的情况下，UUID类型非常好用。



### 2.11.2 Optional类

​	`Optional` 类的主要功能是进行null的相关处理，在以前进行程序开发的时候，如果为了防止程序之中出现空指向异常，可以追加对象是否为null的验证。

```java
class MessageUtil{
    private MessageUtil(){};
    public static IMessage getMessage(){
        return null;
    }
    public static void userMessage(IMessage msg){
        if(msg != null){                                // 在引用接受的一方，是被动的进行判断
            System.out.println(msg.getContent());
        }
    }
}

interface IMessage{
    public String getContent();
}

class MessageImpl implements IMessage{
    @Override
    public String getContent() {
        return "pcr";
    }
}

public class Demo {
    public static void main(String[] args) {
        MessageUtil.userMessage(MessageUtil.getMessage());
    }
}
```

​	为了解决这种被动的处理操作，在Java中提供有一个 Optional 的类，这个类可以实现null的处理操作，在这个类中，提供有如下的一些操作方法：

| 功能                         | 方法                                              |
| ---------------------------- | ------------------------------------------------- |
| 返回空数据                   | public static <T> Optional<T> empty()             |
| 获取数据                     | public T get()                                    |
| 保存数据，但是不允许出现null | public static <T> Optional<T> of(T value)         |
| 保存数据，允许为null         | public static <T> Optional<T> ofNullable(T value) |
| 空的时候返回其他数据         | public T orElse(T other)                          |



### 2.11.3 ThreadLocal类

​	在真正去了解 ThreadLocal 类的作用之前，先编写一个简单的程序做一个分析：

* **示例：现在定义这样一个结构**

  ```java
  class Message1{ // 要发送的消息体
      private String info;
      public void setInfo(String info) {
          this.info = info;
      }
      public String getInfo() {
          return info;
      }
  }
  
  class Channel1{     // 消息的发送通道
      private static Message1 message;
      private Channel1(){}
      public static void setMessage(Message1 message) {
          Channel1.message = message;
      }
  
      public static void send(){
          System.out.println("【消息发送】" + message.getInfo());
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          Message1 msg1 = new Message1();     // 实例化消息主体对象
          msg1.setInfo("保时捷911");                // 设置要发送的内容
          Channel1.setMessage(msg1);          // 设置要发送的消息
          Channel1.send();                    // 发送消息
      }
  }
  ```

  ​	对于当前的程序实际上采用的是一种单线程的模式进行处理的：

  <img src="../../images/高级特性/image-20201022112027217.png" alt="image-20201022112027217" style="zoom:40%;" />

  ​	那么如果在多线程的状态下，能否实现完全一致的操作效果呢？为此我们将启动三个线程进行处理：

* **示例：多线程的影响**

  ```JAVA
  class Message1{ // 要发送的消息体
      private String info;
      public void setInfo(String info) {
          this.info = info;
      }
      public String getInfo() {
          return info;
      }
  }
  
  class Channel1{     // 消息的发送通道
      private static Message1 message;		// Message1 是静态属性
      private Channel1(){}
      public static void setMessage(Message1 message) {
          Channel1.message = message;
      }
  
      public static void send(){
          System.out.println("【" + Thread.currentThread().getName() + "、消息发送】" + message.getInfo());
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          // 三个线程对象
          new Thread(()->{
              Message1 msg1 = new Message1();     // 实例化消息主体对象
              msg1.setInfo("保时捷911-A");                // 设置要发送的内容
              Channel1.setMessage(msg1);          // 设置要发送的消息
              Channel1.send();                    // 发送消息
          }, "消息发送者A").start();
          new Thread(()->{
              Message1 msg1 = new Message1();     // 实例化消息主体对象
              msg1.setInfo("保时捷912-B");                // 设置要发送的内容
              Channel1.setMessage(msg1);          // 设置要发送的消息
              Channel1.send();                    // 发送消息
          }, "消息发送者B").start();
          new Thread(()->{
              Message1 msg1 = new Message1();     // 实例化消息主体对象
              msg1.setInfo("保时捷913-C");                // 设置要发送的内容
              Channel1.setMessage(msg1);          // 设置要发送的消息
              Channel1.send();                    // 发送消息
          }, "消息发送者C").start();
      }
  }
  // 出现如下的输出
  // 【消息发送者A、消息发送】保时捷913-C
  // 【消息发送者C、消息发送】保时捷913-C
  // 【消息发送者B、消息发送】保时捷912-B
  ```

  ​	此时，多线程之间的消息传输相互影响（出现了线程名与消息不匹配的情况），出现了线程不同步的问题

  <img src="../../images/高级特性/image-20201022115455326.png" alt="image-20201022115455326" style="zoom:50%;" />

  

  ​	在保持Channel（所有消息发送的通道）核心结构不改变的情况下，需要考虑到每个线程的独立操作问题。发现对于Channel类而言，除了保留要发送的消息之外，还应该多存放有每一个线程的标记，那么这个时候就可以通过`ThreadLocal`类来存放数据。在ThreadLocal类中提供有如下的操作方法：

  | 功能     | 方法                     |
  | -------- | ------------------------ |
  | 构造方法 | public ThreadLocal()     |
  | 设置数据 | public void set(T value) |
  | 取出数据 | public T get()           |
  | 删除数据 | public void remove()     |

  ​	ThreadLocal类中，存放着线程对象和数据对象，线程对象对外是隐藏的，不需要我们人为去定义或记录

  <img src="../../images/高级特性/image-20201022140324163.png" alt="image-20201022140324163" style="zoom:50%;" />

  ​	最终的程序结构如下：

  <img src="../../images/高级特性/image-20201022140707815.png" alt="image-20201022140707815" style="zoom:50%;" />

* **示例：ThreadLocal解决线程同步问题**

  ```java
  class Message1{
      private String info;
      public void setInfo(String info) {
          this.info = info;
      }
      public String getInfo() {
          return info;
      }
  }
  
  class Channel1{
      private final static ThreadLocal<Message1> THREADLOCAL = new ThreadLocal<Message1>();   // 更改Channel1中存放的数据，由Message1变为ThreadLocal<Message1>
      private Channel1(){}
      public static void setMessage(Message1 message) {
          THREADLOCAL.set(message);       // 向 ThreadLocal 中保存数据
      }
      public static void send(){
          System.out.println("【" + Thread.currentThread().getName() + "、消息发送】" + THREADLOCAL.get().getInfo());    // 根据当前线程对象去取出
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          new Thread(()->{
              Message1 msg1 = new Message1();
              msg1.setInfo("保时捷911-A");
              Channel1.setMessage(msg1);
              Channel1.send();
          }, "消息发送者A").start();
          new Thread(()->{
              Message1 msg1 = new Message1();
              msg1.setInfo("保时捷912-B");
              Channel1.setMessage(msg1);
              Channel1.send();
          }, "消息发送者B").start();
          new Thread(()->{
              Message1 msg1 = new Message1();
              msg1.setInfo("保时捷913-C");
              Channel1.setMessage(msg1);
              Channel1.send();                    
          }, "消息发送者C").start();
      }
  }
  // 最后三个线程的线程和消息是完全对应的，不会出现不匹配的非同步问题
  ```

  

### 2.11.4 定时器

​	定时器的主要操作是进行定时任务的处理。在Java中提供有定时任务的支持，但是这种任务的处理只是实现了一种间隔触发的操作。

​	如果要想实现定时的处理操作，主要需要一个定时操作的主体类，以及一个定时任务的控制。可以使用两个类来实现：

> * `java.util.TimerTask` 类： 实现定时任务处理 , TimerTask 是一个抽象类
>
> <img src="../../images/高级特性/image-20201022143517341.png" alt="image-20201022143517341" style="zoom:50%;" />
>
> * `java.util.Timer` 类： 进行任务的启动，启动的方法：
>
>   > * 延迟毫秒数启动：public void schedule(TimerTask task, long delay)              	 延迟单位为毫秒
>   > * 延迟到某日期启动：public void schedule(TimerTask task, Date time)
>   > * 间隔触发：public void scheduleAtFixedRate(TimerTask task, long delay, long period)

* **示例：实现定时任务处理**

  <img src="../../images/高级特性/image-20201022171759226.png" alt="image-20201022171759226" style="zoom:50%;" />

  ```java
  import java.util.Timer;
  import java.util.TimerTask;
  
  class MyTask extends TimerTask{     // 任务主体
      @Override
      public void run() {   // TimerTask继承自Runnable接口
          System.out.println(Thread.currentThread().getName() + "、定时任务执行，当前时间：" + System.currentTimeMillis());
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          Timer timer = new Timer();
  //        timer.schedule(new MyTask(), 3000);	// 延迟3秒后执行
          timer.scheduleAtFixedRate(new MyTask(), 1000, 3000);   // 1秒后启动，之后每间隔2秒执行一次
      }
  }
  ```

  ​	这种定时是由JDK最原始的方式提供的支持，实际的开发之中利用此类方式进行的定时处理实现的代码会非常的复杂。



### 2.11.5 Base64加密与解密

​	`Base64` 是用来做加密和解密处理的操作类，该类中提供有两个内部类：

> * Base64.Encoder：加密
>
>   ​	public byte[] encode(byte[] src)
>
> * Base64.Decoder：解密
>
>   ​	public byte[] decode(String src)

* **示例：加密与解密处理**

  ```java
  import java.util.Base64;
  
  public class Demo {
      public static void main(String[] args) {
          String msg = "Audi";
          String encMsg = new String(Base64.getEncoder().encode(msg.getBytes()));     // 加密
          System.out.println(encMsg);
          String oriMsg = new String(Base64.getDecoder().decode(encMsg));             // 解密
          System.out.println(oriMsg);
      }
  }
  ```

  ​	虽然 `Base64`可以实现加密与解密的处理，但是由于其是一个公版的算法，所以如果直接对数据进行加密往往并不安全，那么最好的做法是使用盐值操作：

  ```java
  import java.util.Base64;
  
  public class Demo {
      public static void main(String[] args) {
          String salt = "加盐";
          String msg = "Audi" + "{" + salt + "}";
          String encMsg = new String(Base64.getEncoder().encode(msg.getBytes()));     // 加密
          System.out.println(encMsg);
          String oriMsg = new String(Base64.getDecoder().decode(encMsg));             // 解密
          System.out.println(oriMsg);
      }
  }
  ```

  ​	即便现在有盐值，实际上发现加密的保密性也不是很好，更好的方法是进行多次加密：

  ```java
  import java.util.Base64;
  
  class StringUtil{
      private static final String SALT = "{公版盐值}";      // 公共的盐值
      private static final int REPEAT = 5;                // 默认的加密重复次数
      /**
       * 加密处理
       * @param str       要加密的字符串，需要与盐值整合
       * @return          加密后的数据
       */
      public static String encode(String str){           // 加密处理
          String temp = str + SALT ;                   // 盐值对外不公布
          byte[] data = temp.getBytes();      // 将字符串变为字节数组
          for(int x=0; x< REPEAT; x++){
              data = Base64.getEncoder().encode(data);        // 重复加密
          }
          return new String(data);
      }
  
      /**
       * 解密
       * @param str   要解密的内容
       * @return      解密后的原始数据
       */
      public static String decode(String str){
          byte[] data = str.getBytes();
          for(int x=0; x<REPEAT; x++){
              data = Base64.getDecoder().decode(data);
          }
          return new String(data).replaceAll("\\{\\W+\\}", "");
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          String str = StringUtil.encode("ph764134674");
          System.out.println(str);
          String oriStr = StringUtil.decode(str);
          System.out.println(oriStr);
      }
  }
  ```



## 2.12 类库使用案例

### 2.13.1 StringBuffer使用

* **示例**

  ​	定义一个StringBuffer类对象，然后通过append()方法向对象中添加26个小写字母，要求每次只添加一个，共添加26次，然后按照逆序的方式输出，并且可以删除前5个字符。

  ```java
  public class Demo {
      public static void main(String[] args) {
          StringBuffer stringBuffer = new StringBuffer();
          for(int x='a'; x<='z'; x++){
              stringBuffer.append((char) x);
          }
          stringBuffer.reverse();     // 反转处理
          stringBuffer.delete(0, 5);
          System.out.println(stringBuffer.toString());
      }
  }
  ```




### 2.13.2 随机数组

* **示例：利用Random类产生5个1-30之间（包括1和30）的随机整数**

  ​	说明：Random 产生随机数的操作中会产生数字0

  ```java
  import java.util.Arrays;
  import java.util.Random;
  
  class NumberFactory{
      private static Random random = new Random();
      /**
       * 通过随机数来生成一个数组的内容，该内容不包括0
       * @param len       要开辟的数组大小
       * @return          包含有随机数的内容
       */
      public static int[] create(int len){
          int data[] = new int [len];
          int foot = 0;
          while(foot<data.length){
              int num = random.nextInt(30);
              if(num!=0){
                  data[foot++] = num;     //保存数据
              }
          }
          return data;
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          int[] result = NumberFactory.create(10);
          System.out.println(Arrays.toString(result));
      }
  }
  ```

  



# 三、比较器

​	所谓的比较器指的就是进行大小关系的确定判断，首先分析一下比较器存在的意义：

## 3.1 比较器问题的引出

​	如果要进行数组操作，肯定使用 `java.util.Arrays`的操作类完成，这个类里面提供有绝大部分的数组操作支持，同时在这个类中还提供有一种对象数组的排序支持：public static void sort(Object[] a)

* **示例：实现对象数组的排序**

  ```java
  import java.util.Arrays;
  
  public class Demo {
      public static void main(String[] args) {
          Integer[] data = new Integer[]{15,6,7,6,45,86,13,47};
          Arrays.sort(data);
          System.out.println(Arrays.toString(data));
      }
  }
  ```

  ​	同样，如果给定的是String类型的对象数组，那么也是可以进行排序处理的：

  ```java
  import java.util.Arrays;
  
  public class Demo {
      public static void main(String[] args) {
          String[] data = new String[]{"x","g","i","q","l","y",};
          Arrays.sort(data);
          System.out.println(Arrays.toString(data));
      }
  }
  ```

  ​	问题：`java.lang.Integer`和`java.lang.String`两个类都是由系统提供的程序类，那么如果现在有一个自定义类需要实现排序处理呢？

* **示例：采用自定义类型进行排序**

  ```java
  import java.util.Arrays;
  
  class Person{
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
      @Override
      public String toString() {
          return "【Person类对象】姓名：" + this.name + "、年龄：" + this.age + "\n";
      }
      // 无参构造、setter、getter这里省略不写了
  }
  
  public class Demo {
      public static void main(String[] args) {
          Person[] per = new Person[]{
              new Person("小陈-A", 22),
              new Person("小陈-B", 26),
              new Person("小陈-C", 18),
          };
          Arrays.sort(per);
          System.out.println(Arrays.toString(per));
      }
  }
  ```

  ​	以上程序编译时没有错误，但是运行时出现异常：

  ![image-20201022193709932](../../images/高级特性/image-20201022193709932.png)

  ​	任意的一个类，默认情况下是无法使用系统内部的类实现数组排序或比较功能的，不能比较的原因在于我们没有明确的指定该如何进行比较的定义（没有比较规则），在Java中为了统一比较规则的定义，所以提供有比较器的接口：`Comparable`接口。



## 3.2 Comparable 比较器

​	通过上节分析可以发现如果要实现对象的比较肯定需要有比较器来制定比较规则，而比较的规则就通过Comparable接口来实现，对于Comparable而言，需要清楚其基本的定义结构：`public int compareTo(T o)`

```java
public interface Comparable<T> {
    /**
     * 实现对象间的比较
     * @param o     要比较的对象
     * @return      当前对象比传入的对象小，返回负数，如果大于，返回整数，相等则返回0
     */
    public int compareTo(T o);
}
```

* **示例：实现自定义对象数组排序操作**

  ```java
  import java.util.Arrays;
  
  class Person implements Comparable<Person>{
      private String name;
      private int age;
  
      @Override
      public int compareTo(Person per) {
          return this.age - per.age;
      }
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
      @Override
      public String toString() {
          return "【Person类对象】姓名：" + this.name + "、年龄：" + this.age + "\n";
      }
  
      // 无参构造、setter、getter这里省略不写了
  }
  
  public class Demo {
      public static void main(String[] args) {
          Person[] per = new Person[]{
              new Person("小陈-A", 22),
              new Person("小陈-B", 26),
              new Person("小陈-C", 18),
          };
          Arrays.sort(per);			// public static void sort(Object[] a)
          System.out.println(Arrays.toString(per));
      }
  }
  ```

  ​	排序中，只需要有一个compareTo()方法进行排序规则的定义，而后整个Java系统中，就可以为其实现排序处理。



## 3.3 Comparator 比较器

​	`Comparator` 属于一种挽救的比较器支持，其主要目的是解决一些没有使用`Comparable`排序的类的对象数组排序。

* **示例：现在程序项目已经开发完成了，并且由于先期的设计并没有考虑到所谓的比较器功能**

  ```java
  class Person{
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
      @Override
      public String toString() {
          return "【Person类对象】姓名：" + this.name + "、年龄：" + this.age + "\n";
      }
  
      // 无参构造、setter、getter这里省略不写了
  }
  ```

  ​	后来经过了若干版本的迭代更新之后，发现需要对Person类进行排序处理，但是又不能去修改Person类（意味着无法实现Comparable接口），所以这时就需要采用一种挽救的形式来实现比较——Comparator。

  ​	在 `java.util.Comparator` 中，最初只定义有一个排序的 compare() 方法：`public int compare(T o1, T o2)`		但是后来持续发展又出现了许多的static方法。

* **示例：使用Comparator定义排序规则类**

  ```java
  class PersonComparator implements Comparator<Person>{
      @Override
      public int compare(Person p1, Person p2) {
          return p1.getAge() - p2.getAge();
      }
  }
  ```

  ​	完成程序代码：

  ```java
  import java.util.Arrays;
  import java.util.Comparator;
  
  class Person{
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
      @Override
      public String toString() {
          return "【Person类对象】姓名：" + this.name + "、年龄：" + this.age + "\n";
      }
  
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
      public int getAge() {
          return age;
      }
      public void setAge(int age) {
          this.age = age;
      }
  }
  
  class PersonComparator implements Comparator<Person>{
      @Override
      public int compare(Person p1, Person p2) {
          return p1.getAge() - p2.getAge();
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          Person[] per = new Person[]{
                  new Person("小陈-A", 22),
                  new Person("小陈-B", 26),
                  new Person("小陈-C", 18),
          };
          Arrays.sort(per, new PersonComparator());	//public static <T> void sort(T[] a, Comparator<? super T> c)
          System.out.println(Arrays.toString(per));
      }
  }
  ```

  ​	对于这种排序的操作，如果不是必须的情况下，强烈建议不要使用`Comparator`，**最好以`Comparable`为主。**

* **面试题：请解释 Comparable 与 Comparator 的区别？**
  
  1. `java.lang.Comparable`是在类定义的时候去实现该接口，主要用于定义排序规则，里面只有`compareTo()`方法
  2. `java.util.Comparator`是挽救的比较器操作，<u>需要设置单独的比较器规则类</u>实现排序，里面有`compare()`方法和其他很多方法

# 四、IO操作

​	Java中在`java.io.File`中提供有对文件操作的支持，如果要进行`File`类的操作，必须要提供完整的路径，而后调用相应的方法。

## 4.1 File类基本操作

​	`File`类是Comparable接口的子类，所以File类的对象是可以进行排序处理的。在进行`File`类处理的时候，需要为其设置访问路径，对于路径的配置，主要通过`File`类的构造方法：

> * 构造方法：==public File(String pathname)==						设置要操作的完整路径
> * 构造方法：public File(String parent, String child)          设置父路径与子目录

​	进行文件的基本操作，使用如下方法：

> * 判断文件是否存在：==public boolean exists()==
> * 创建新的文件：public boolean createNewFile() throws IOException		返回true表示不存在该文件名，可以创建该文件；返回false表示该目录中存在该文件名，不可以重复创建
> * 删除文件：==public boolean delete()==

* **示例：使用`File`类创建一个文件**

  ```java
  import java.io.File;
  import java.io.IOException;
  
  public class Demo {
      public static void main(String[] args) throws IOException {
          File file = new File("d:\\File.txt");      // 注意这里是两个“\”
          if(file.exists()){  // 文件已存在
              file.delete();  // 删除文件
              System.out.println("删除文件成功！");
          }
          System.out.println(file.createNewFile());       // 创建新的文件
      }
  }
  ```



## 4.2 File 类操作深入

* **不同系统的路径分隔符**

  ​	在实际的软件开发和运行过程中，往往会在Windows中进行项目开发，在项目部署时基于Linux以保证生产环节的安全性。

  ​	在不同的操作系统中会存在有不同的路径分隔符：Windows分隔符“\”，Linux分隔符“/”，所以在最初进行开发时就必须考虑不同系统环境下的分隔符的问题，所以为了解决此问题，File类提供有一个常量：public static final String separator，所以规范的路径应该如下：

  ```java
  File file = new File("d:" + File.separator + "File.txt");
  ```

  ​	但是随着系统的适应性的不断加强，对于当前的路径操作，也可以随意使用了。（Windows系统当中也可以使用“/”作为分隔符，或者Linx也可以使用"\\"作为分隔符）

*  **注意事项**

  ​	在进行文件创建时有一个重要前提：文件的父路径必须首先存在

  > * ==获取父路径：public File getParentFile()==
  >
  > * ==创建目录：public boolean mkdirs()==

  * 示例

    ```java
    import java.io.File;
    import java.io.IOException;
    
    public class Demo {
        public static void main(String[] args) throws IOException {
            File file = new File("d:"+ File.separator + "FileCreate" + File.separator  +  "test" + File.separator + "demo" + File.separator  +"File.txt");
            if(!file.getParentFile().exists()){     // 目录不存在
                file.mkdirs();              // 创建目录
            }
            if(file.exists()){  // 文件已存在
                file.delete();  // 删除文件
                System.out.println("删除文件成功！");
            }
            System.out.println(file.createNewFile());       // 创建新的文件
        }
    }
    ```

    ​	这种判断并且建立父目录的操作在很多情况下可能只需要一次，但是如果将这个判断一直停留在代码中，那么会造成时间复杂度的提升，所以这个时候如果要想提升性能，请先保证目录已经创建。



## 4.3 获取文件信息

