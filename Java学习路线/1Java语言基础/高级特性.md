[toc]



# 一 多线程

## 1.1 多线程编程

### 1.1.1 **继承Thread类实现多线程**

```java
class MyThread extends Thread{
    private String title;
    public MyThread(String title){
        this.title = title;
    }

    @Override
    public void run() {
        for(int x = 0; x<10; x++){
            System.out.println(this.title + "运行，x=" + x);
        }
    }
}

class ThreadDemo{
    public static void main(String[] args) {
        new MyThread("线程A").start();	// 这里如果使用run方法，三个线程是顺序执行的，并没有并行执行
        new MyThread("线程B").start();
        new MyThread("线程C").start();
    }
}
```

​	虽然调用的是start()方法，但最终执行的是run()方法，并且所有的线程对象都是交替执行的，执行顺序是不可控的。为什么多线程的启动不直接使用run()方法，而必须使用Thread类中的start()方法呢？

​	在Java程序的执行过程之中，考虑到对于不同层次开发者的需求，所以其支持有本地的操作系统函数调用，而这项技术被称为JNI（Java Native Interface），但是Java开发过程之中并不推荐这样使用，利用这项技术可以使用一些操作系统提供的底层函数进行一些特殊的处理，而在Thread类里面提供的`start0()` 就表示需要将此方法依赖于不同的操作系统实现。



### 1.1.2 基于Runnable接口实现多线程



### 1.1.3 Thread 与 Runnable 的关系

<img src="../../images/高级特性/image-20200929174633701.png" alt="image-20200929174633701" style="zoom:67%;" />

​	例子：利用卖票程序来实现多个线程的资源并发访问

```java
class MyThread implements Runnable{
    private int ticket = 5;
    @Override
    public void run(){
        for(int x=0; x<100; x++){
            if(this.ticket > 0){
                System.out.println("卖票，ticket = " + this.ticket--);
            }
        }
    }
}

class Example{
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        new Thread(mt).start();         // 第一个线程启动
        new Thread(mt).start();         // 第二个线程启动
        new Thread(mt).start();         // 第三个线程启动
    }
}
```



### 1.1.4 Callable 实现多线程

​	Runnable接口有一个缺点：当线程执行完毕之后，无法获取一个返回值。从JDK1.5之后提出了一个新的线程实现接口：java.util.concurrent.Callable接口

```java
public interface Callable<V>{
    public V call() throws Excetion;
}
```

​	可以发现Callable定义的时候可以设置一个泛型，此泛型的类型就是返回数据的类型，这样的好处是可以避免向下转型带来的安全隐患。

<img src="../../images/高级特性/image-20200929182745902.png" alt="image-20200929182745902" style="zoom:50%;" />

* **示例：**

  使用Callable实现多线程

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class MyThread implements Callable<String>{
    @Override
    public String call() throws Exception{
        for(int x=0; x<10; x++){
            System.out.println("********* 线程执行" + x);
        }
        return "线程执行完毕";
    }
}

class Example{
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<String> task = new FutureTask<>(new MyThread());
        new Thread(task).start();
        System.out.println("【线程返回数据】" + task.get());
    }
}
```

* **面试题：请解释Runnable与Callable的区别？**

  java.lang.Runnable 接口之中只提供有一个run()方法，并且没有返回值

  java.util.concurrent.Callable接口提供有Call()方法，可以有返回值



### 1.1.5 线程运行状态

<img src="../../images/高级特性/image-20200929183933815.png" alt="image-20200929183933815" style="zoom:67%;" />



## 1.2 线程常用操作方法

### 1.2.1 线程的命名与取得

​	多线程的运行状态是不确定的，那么在程序的开发之中为了可以获取到一些需要使用的线程就只能够依靠线程的名字来进行操作。所以线程的名字是一个至关重要的概念，这样在Thread类之中就提供有线程名称的处理。

|          |                                             |
| -------- | ------------------------------------------- |
| 构造方法 | public Thread(Runnable target, String name) |
| 设置名字 | public final void setName(String name)      |
| 取得名字 | public final String getName()               |



### 1.2.2 线程的休眠

| 方法定义                                                     |
| ------------------------------------------------------------ |
| public static void sleep(long millis) throws InterruptedExcetion |
| public static void sleep                                     |

​	在进行休眠的时候可能会产生中断异常`InterruptedExcetion`，中断异常属于Exception的子类，所以证明该异常必须进行处理。

```java
class Demo{
    public static void main(String[] args) {
        new Thread(()->{
           for(int x=0; x<10; x++){
               System.out.println(Thread.currentThread().getName() + "、x=" + x);
               try {
                   Thread.sleep(1000);      // 暂缓执行
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
        },"线程对象").start();
    }
}
```

​	休眠的主要特点是可以自动进行线程的唤醒，以继续进行后续的处理。但是需要注意的是，如果现在你有多个线程对象，那么休眠也是有先后顺序的。

* **示例：产生多个线程对象进行休眠**

```java
public class Demo {
    public static void main(String[] args) {
        Runnable run = ()->{
            for(int x=0; x<10; x++){
                System.out.println(Thread.currentThread().getName() + "、x=" + x);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        for(int num=0; num<5; num++){
            new Thread(run, "线程对象-" + num).start();			// 产生五个线程对象
        }
    }
}
```

​	此时将产生5个线程对象，并且这五个线程对象执行的方法体是相同的。此时从程序执行的感觉上来讲，好像是若干个线程一起进行了休眠，而后一起进行了自动唤醒，但是实际上是有差别的。

<img src="../../images/高级特性/image-20201010101303104.png" alt="image-20201010101303104" style="zoom:67%;" />



### 1.2.3 线程中断

​	某个线程的中断是由其它线程完成的，在Thread类中提供有两种中断执行的处理方法：

> * 判断线程是否被中断：public boolean isInterrupted()
> * 中断线程执行：public void interrupt()

* **示例：线程中断的处理操作**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Thread thread = new Thread(()->{
              System.out.println("***线程启动***");
              try{
                  Thread.sleep(10000);
                  System.out.println("***线程执行完毕***");
              }catch (InterruptedException e){
                  e.printStackTrace();
              }
          });
          thread.start();
          if(!thread.isInterrupted()){    // 判断线程是否中断，如果没有中断，则执行线程的中断操作
              thread.interrupt();         // 中断线程的执行
          }
      }
  }
  ```

  ​	执行结果：

  <img src="../../images/高级特性/image-20201010105053133.png" alt="image-20201010105053133" style="zoom:67%;" />

  所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理。



### 1.2.4 线程强制运行

​	所谓的线程的强制执行指的是当满足某些条件之后，某一个线程对象将可以一直独占资源，一直到该线程的程序执行结束。线程的强制执行可以使用Thread中提供的方法：`join()`

* **示例：观察一个没有强制执行的程序**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Thread thread = new Thread(()->{
              for(int x=0; x<100; x++){
                  try {
                      Thread.sleep(100);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "执行、x=" + x);
              }
          },"玩耍的线程");
          thread.start();
          for(int x=0; x<100; x++){
              Thread.sleep(100);
              System.out.println("【霸道的main线程】number=" + x);
          }
      }
  }
  ```

  ​	以上程序代码，主线程和子线程在交替执行着，但是如果希望主线程独占执行，那么可以使用Thread类中的方法：强制执行。

* **线程强制执行的程序**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Thread mainThread = Thread.currentThread();     // 获得主线程
          Thread thread = new Thread(()->{
              for(int x=0; x<100; x++){
                  if(x==3){       // 现在霸道的线程要来了
                      try {
                          mainThread.join();      // 霸道线程要先执行
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                  }
                  try {
                      Thread.sleep(100);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "执行、x=" + x);
              }
          },"玩耍的线程");
          thread.start();
          for(int x=0; x<100; x++){
              Thread.sleep(100);
              System.out.println("【霸道的main线程】number=" + x);
          }
      }
  }
  ```

  ​	在进行线程强制执行的时候，一定要获取强制执行线程对象之后，才可以执行`join()`的调用。



### 1.2.5 线程礼让

​	线程的礼让指的是先将资源让出去，让别的线程先执行。线程的礼让可以使用Thread中提供的方法：`public static void yield()`

* **示例：线程的礼让操作**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Thread thread = new Thread(()->{
              for(int x=0; x<100; x++){
                  if(x%3 == 0){
                      Thread.yield(); // 线程礼让
                      System.out.println("### 玩耍的线程礼让执行 ###");
                  }
                  try {
                      Thread.sleep(100);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "执行、x=" + x);
              }
          },"玩耍的线程");
          thread.start();
          for(int x=0; x<100; x++){
              Thread.sleep(100);
              System.out.println("【霸道的main线程】number=" + x);
          }
      }
  }
  ```



### 1.2.6 线程优先级

​	从理论上说，线程的优先级越高越有可能先执行（越有可能先抢占到资源）。Thread类中针对优先级操作提供有以下两个处理方法：

| 功能       | 方法                                           |
| ---------- | ---------------------------------------------- |
| 设置优先级 | public final void setPriority(int newPriority) |
| 获取优先级 | public final int getPriority()                 |

​	在进行优先级定义的时候都是通过int型的数字来完成的，而对于此数字的选择在Thread类中定义有三个常量：

| 功能       | 常量                                  |
| ---------- | ------------------------------------- |
| 最高优先级 | public static final int MAX_PRIORITY  |
| 中等优先级 | public static final int NORM_PRIORITY |
| 最低优先级 | public static final int MIN_PRIORITY  |

* **示例：线程优先级操作**

  ```java
  class Demo{
      public static void main(String[] args) throws Exception {
          Runnable run = ()->{
              for(int x=0; x<10; x++){
                  try {
                      Thread.sleep(1000);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + "执行。");
              }
          };
          Thread threadA = new Thread(run, "线程对象A");
          Thread threadB = new Thread(run, "线程对象B");
          Thread threadC = new Thread(run, "线程对象C");
          threadA.setPriority(Thread.MAX_PRIORITY);
          threadB.setPriority(Thread.MIN_PRIORITY);
          threadC.setPriority(Thread.MIN_PRIORITY);
          threadA.start();
          threadB.start();
          threadC.start();
      }
  }
  ```

  ​	以上程序，A有较大概率先执行，但并不是每次都最先执行。即优先级高的线程有可能先执行，并不是绝对会先执行。



## 1.3 线程同步与死锁

​	在多线程的处理中，可以利用Runnable描述多个线程操作的资源，而Thread描述每一个线程对象，于是当多个线程访问同一资源的时候，如果处理不当，就会产生数据的错误操作。

### 1.3.1 同步问题的引出

​	下面编写一个简单的卖票程序，将创建若干个线程对象实现卖票的处理操作。

```JAVA
class MyThread implements Runnable{
    private int ticket = 10; //总票数为10张
    @Override
    public void run() {
        while(true){
            if(this.ticket>0){
                try {
                    Thread.sleep(100);      // 模拟网络延迟
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "卖票，ticket = " + this.ticket --);
            } else{
                System.out.println("*** 票已售罄 ***");
                break;
            }
        }
    }
}

class Demo{
    public static void main(String[] args) throws Exception {
        MyThread myThread = new MyThread();
        new Thread(myThread, "票贩子A").start();
        new Thread(myThread, "票贩子B").start();
        new Thread(myThread, "票贩子C").start();
    }
}
```

​	由于手动添加了线程休眠来模拟网络延迟的情况，以上程序在多次运行中可能出现剩余票数为-1的情况，程序运行过程如下：

<img src="../../images/高级特性/image-20201010143442591.png" alt="image-20201010143442591" style="zoom:67%;" />



### 1.3.2 线程同步处理

​	解决同步问题的关键在于锁。锁指的是当某一个线程执行操作的时候，其它线程在外面等着。

<img src="../../images/高级特性/image-20201010143959035.png" alt="image-20201010143959035" style="zoom:67%;" />

​	如果想在程序之中实现这把锁的功能，就可以使用synchronized关键字来实现，利用此关键字可以定义同步方法或同步代码块，在同步代码块的操作里面的代码只允许一个线程执行。

* **利用同步代码块进行处理**

  ```java
  synchronized(同步对象){
      同步代码操作;
  }
  ```

  ​	一般要进行同步对象处理的时候可以采用当前对象this进行同步

  * 示例：利用同步代码块解决数据同步访问问题

    ```java
    class MyThread implements Runnable{
        private int ticket = 10000;
        @Override
        public void run() {
            while(true){
                synchronized (this){        // 每次只允许一个线程进行访问
                    if(this.ticket>0){
                        try {
                            Thread.sleep(1);      // 模拟网络延迟
                        }catch (InterruptedException e){
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "卖票，ticket = " + this.ticket --);
                    } else{
                        System.out.println("*** 票已售罄 ***");
                        break;
                    }
                }
            }
        }
    }
    
    class Demo{
        public static void main(String[] args) throws Exception {
            MyThread myThread = new MyThread();
            new Thread(myThread, "票贩子A").start();
            new Thread(myThread, "票贩子B").start();
            new Thread(myThread, "票贩子C").start();
        }
    }
    ```

* **利用同步方法解决：只需要在方法定义上使用synchronized关键字即可**

  ```java
  class MyThread implements Runnable{
      private int ticket = 10;
  
      public synchronized boolean sale(){
          if(this.ticket>0){
              try {
                  Thread.sleep(100);      // 模拟网络延迟
              }catch (InterruptedException e){
                  e.printStackTrace();
              }
              System.out.println(Thread.currentThread().getName() + "卖票，ticket = " + this.ticket --);
              return true;
          } else{
              System.out.println("*** 票已售罄 ***");
              return false;
          }
      }
  
      @Override
      public void run() {
          while(this.sale()){
          }
      }
  }
  
  class Demo{
      public static void main(String[] args) throws Exception {
          MyThread myThread = new MyThread();
          new Thread(myThread, "票贩子A").start();
          new Thread(myThread, "票贩子B").start();
          new Thread(myThread, "票贩子C").start();
      }
  }
  ```



## 1.4 经典示例

​		在多线程的开发过程中，最为著名的案例是生产者与消费者操作，该操作的主要流程如下：

> * 生产者负责信息内容的生产
>
> * 每当生产者生产完成一项完整的信息之后消费者要从这里面取走信息
>
> * 如果生产者没有生产则消费者要等待它生产完成，如果消费者还没有对信息进行消费，则生产者应该等待消费处理完成后再继续生产。

<img src="../../images/高级特性/image-20201010170059452.png" alt="image-20201010170059452" style="zoom:67%;" />

* **程序的基本实现**

  ​	可以将生产者与消费者定义为两个独立的线程类对象，但是对于现在生产的数据，可以使用如下的组成：

  > * 数据一：title = 张大、content = 家中老大
  > * 数据二：title = 张二、content = 家中老二

  ​	既然生产者与消费者是两个独立的线程，那么这两个独立的线程之间就需要有一个数据保存的集中点，那么可以单独定义一个Message类来进行数据的保存

  ```java
  // 生产者
  class Producer implements Runnable{
      private Message msg;
      public Producer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              if(x%2 == 0){
                  this.msg.setTitle("张大");
                  try{
                      Thread.sleep(100);
                  } catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  this.msg.setContent("家中老大");
              }else{
                  this.msg.setTitle("张二");
                  try{
                      Thread.sleep(100);
                  } catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  this.msg.setContent("家中老二");
              }
          }
      }
  }
  
  // 消费者
  class Consumer implements Runnable{
      private Message msg;
      public Consumer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              try{
                  Thread.sleep(10);
              } catch (InterruptedException e){
                  e.printStackTrace();
              }
              System.out.println(this.msg.getTitle() + "   -   " + this.msg.getContent());
          }
      }
  }
  
  // 保存的数据
  class Message{
      private String title;
      private String content;
  
      public void setTitle(String title) {
          this.title = title;
      }
      public void setContent(String content) {
          this.content = content;
      }
      public String getTitle() {
          return title;
      }
      public String getContent() {
          return content;
      }
  }
  
  // 主方法
  class Demo{
      public static void main(String[] args) throws Exception {
          Message msg = new Message();
          new Thread(new Producer(msg)).start();      // 启动生产者线程
          new Thread(new Consumer(msg)).start();      // 启动消费者线程
      }
  }
  ```

  ​	通过整个代码的执行会发现此时有两个主要问题：

  > 问题一：数据不同步（出现了“张大-家中老二”和“张二-家中老大”的记录）
  >
  > 问题二：应该是生产一个取走一个，但是发现有了重复生产和重复取出的问题

* **解决数据同步的问题**

  ​	如果要想解决数据同步，最简单的做法是使用synchronized关键字定义同步代码块或同步方法，于是这个时候对于同步的处理就可以直接在Message类中完成。

  ```java
  class Producer implements Runnable{
      private Message msg;
      public Producer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              if(x%2 == 0){
                  this.msg.set("张大", "家中老大");
              }else{
                  this.msg.set("张二", "家中老二");
              }
          }
      }
  }
  
  class Consumer implements Runnable{
      private Message msg;
      public Consumer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              System.out.println(this.msg.get());
          }
      }
  }
  
  class Message{
      private String title;
      private String content;
  
      public synchronized void set(String title, String content){		// 同步方法
          this.title = title;
          try{
              Thread.sleep(100);
          } catch (InterruptedException e){
              e.printStackTrace();
          }
          this.content = content;
      }
      public synchronized String get(){				// 同步方法
          try{
              Thread.sleep(100);
          } catch (InterruptedException e){
              e.printStackTrace();
          }
          return this.title + "   -   " + this.content;
      }
  }
  
  class Demo{
      public static void main(String[] args) throws Exception {
          Message msg = new Message();
          new Thread(new Producer(msg)).start();      // 启动生产者线程
          new Thread(new Consumer(msg)).start();      // 启动消费者线程
      }
  }
  ```
  
  ​	上面程序的执行结果：数据已经可以保持一致了（不再出现“张大-家中老二”和“张二-家中老大”的情况），但是对于重复操作的问题依然存在。

* **线程等待与唤醒**

  ​	如果要解决生产者与消费者问题，最好的解决方案是使用等待与唤醒机制。而对于等待与唤醒的机制，主要依赖Object类中提供的方法处理：

  | 功能         | 方法                                                         |
  | ------------ | ------------------------------------------------------------ |
  | 等待         | public final void wait() throws InterruptedException         |
  | 设置等待时间 | public final void wait(long timeout) throws InterruptedExption |
  | 设置等待时间 | public final void wait(long timeout, int nanos) throws InterruptedExption |

  | 功能               | 方法                          |
  | ------------------ | ----------------------------- |
  | 唤醒第一个等待线程 | public final void notify()    |
  | 唤醒全部等待线程   | public final void notifyAll() |

  ​	对于当前的问题主要的解决方法应该通过Message类完成

  ```java
  class Producer implements Runnable{
      private Message msg;
      public Producer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              if(x%2 == 0){
                  this.msg.set("张大", "家中老大");
              }else{
                  this.msg.set("张二", "家中老二");
              }
          }
      }
  }
  
  class Consumer implements Runnable{
      private Message msg;
      public Consumer(Message msg){
          this.msg = msg;
      }
      @Override
      public void run() {
          for(int x=0; x<100; x++){
              System.out.println(this.msg.get());
          }
      }
  }
  
  class Message{
      private String title;
      private String content;
      private boolean flag = true;       // 表示生产或消费的形式
      // flag = true;             // 允许生产，不允许消费
      // flag = false;            // 允许消费，不允许生产
      public synchronized void set(String title, String content){
          if(this.flag == false){         // 无法进行生产，应该等待被消费
              try{
                  super.wait();
              } catch (InterruptedException e){
                  e.printStackTrace();
              }
          }
          this.title = title;
          try{
              Thread.sleep(100);
          } catch (InterruptedException e){
              e.printStackTrace();
          }
          this.content = content;
          this.flag = false;          // 已经生产过了
          super.notify();             // 生产完成后，也有可能存在等待的消费者，所以这里唤醒等待的线程（有就唤醒，没有就什么也不做）
      }
      public synchronized String get(){
          if(this.flag == true){      // 还未生产，需要等待
              try{
                  super.wait();
              } catch (InterruptedException e){
                  e.printStackTrace();
              }
          }
          try{
              Thread.sleep(100);
          } catch (InterruptedException e){
              e.printStackTrace();
          }
          try{
              return this.title + "   -   " + this.content;
          } finally {     // 不管如何都要执行
              this.flag = true; // 继续生产
              super.notify();     // 唤醒等待线程
          }
  
      }
  }
  
  class Demo{
      public static void main(String[] args) throws Exception {
          Message msg = new Message();
          new Thread(new Producer(msg)).start();      // 启动生产者线程
          new Thread(new Consumer(msg)).start();      // 启动消费者线程
      }
  }
  ```

  ​	这种处理形式就是在进行多线程开发过程之中最原始的处理方案，整个的等待、同步、唤醒机制都由开发者自行通过原生代码实现控制。